<?php
/**
 *
 * @copyright &copy; 2010 The Open University
 * @author a.j.forth@open.ac.uk
 * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
 * @package dataplus
 */
require_once("sqlite3_db.php");
require_once("lib.php");

class sqlite3_db_dataplus extends sqlite3_db {

    //version of the DataPlus db generated by this code
    private $version = 1.207;

    /**
     * @param string $db_id
     * @param boolean $lock
     * @param string $path
     */
    public function __construct($db_id, $lock = false, $path = null){
        parent::__construct($db_id, $lock);

        //if this database did not previously exist, add the supporting columns and tables required
        if (!$this->table_exists('content')) {
            $this->setup_tables();
        }

        $version = $this->needs_upgrade();

        if ($version !== false) {
            if (!$this->upgrade($version)) {
                print_error('Database upgrade failed.');
            }
        }
    }


    /**
     * Returns the version of the DataPlus db created by this class
     *
     * @return float
     */
    public function get_version(){
        return $this->version;
    }


    /**
     *  returns the information required for a standard primary key
     *
     *  @return array
     */
    private function define_basic_columns(){
        $columns = array();

        $columns[0]->name = 'id';
        $columns[0]->type = 'integer';
        $columns[0]->primary_key = true;
        $columns[0]->autoincrement = true;
        $columns[0]->notnull = true;
        $columns[0]->label = get_string('id','dataplus');
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        return $columns;
    }


    /**
     * umbrella for setting up all the tables and columns needed for a DataPlus database.
     * These tables record information a content table for storing user data with auto generated supporting 
     * fields(creator, last user and group info), a table for recording information in the columns in other 
     * tables (columns) - this is necessary due to shortcomings in the support for pragma is SQLite, and a 
     * templates table for user templates
     *
     */
    private function setup_tables(){
        $supporting_columns = $this->detail_content_table_supporting_columns();

        $this->create_table("content",$supporting_columns);

        $column = array();

        $column[0]->name = 'name';
        $column[0]->value = 'id';

        $column[1]->name = 'label';
        $column[1]->value = 'id';

        $column[2]->name = 'type';
        $column[2]->value = "integer";

        $column[3]->name = 'primary_key';
        $column[3]->value =  1;

        $column[4]->name = 'autoincrement';
        $column[4]->value =  1;

        $column[5]->name = 'not_null';
        $column[5]->value =  1;

        $column[6]->name = 'table_name';
        $column[6]->value = 'content';

        $this->insert_record("column",$column);

        foreach ($supporting_columns as $supporting) {
            $column = array();
            $i = 0;

            foreach ($supporting as $name => $value) {
                $column[$i]->name = $name;
                $column[$i]->value = $value;
                $i++;
            }

            $column[$i]->name = 'table_name';
            $column[$i]->value = 'content';

            $this->insert_record("column",$column);
        }

        $this->setup_templates_table();
        $this->setup_supporting_table();
        $this->setup_comments_table();
        $this->set_file_db_domain();
        $this->set_file_db_version();
    }


    /**
     * Get the db version currently associated with the db file
     * 
     * @return string
     */
    function get_file_db_version(){
        return $this->get_supporting_setting('version');
    }


    /**
     * Set the database version
     * 
     * @ return boolean
     */
    public function set_file_db_version(){
        return $this->set_supporting_setting('version', $this->get_version(), $this->get_file_db_version());
    }


     /**
     * Get the db domain currently associated with the db file
     * 
     * @return string
     */
    function get_file_db_domain(){
        return $this->get_supporting_setting('domain');
    }


    /*
     * Sets the domain under which the db was created.
     * 
     * @return boolean
     */
    public function set_file_db_domain(){
        global $CFG;

        return $this->set_supporting_setting('domain', $CFG->wwwroot, $this->get_file_db_domain());
    }


    /**
     * Gets a supporting info setting from the supportinginfo table
     * 
     * @param string name
     * @return mixes
     */
    function get_supporting_setting($name){
        $columns = array('val');

        $parameters = array();
        $parameters[0]->name = 'variable';
        $parameters[0]->value = $name;
        $parameters[0]->operator = 'equals';

        $result = $this->query_database_single("supportinginfo",$columns,$parameters);

        if (!$result) {
            return $result;
        }

        return $result->val;
    }


    /**
     * Set supporting setting
     * 
     * @param string name
     * @param string value
     * @return boolean
     */
    function set_supporting_setting($name, $value, $exists){
        $columns[0]->name = 'variable';
        $columns[0]->value = $name;

        $columns[1]->name = 'val';
        $columns[1]->value = $value;

        if (!$exists) {
           return $this->insert_record("supportinginfo",$columns);
        }

        $parameters[0]->name = 'variable';
        $parameters[0]->value = $name;
        $parameters[0]->operator = 'equals';

        return $this->update_record("supportinginfo",$columns,$parameters); 
    }


    /**
     * Creates the user templates table
     * 
     * @return boolean
     */
    protected function setup_templates_table(){
        $columns = $this->define_basic_columns();

        $columns[1]->name = 'css';
        $columns[1]->type = 'text';

        $columns[2]->name = 'js';
        $columns[2]->type = 'text';

        $columns[3]->name = 'header';
        $columns[3]->type = 'text';

        $columns[4]->name = 'record';
        $columns[4]->type = 'text';

        $columns[5]->name = 'comments';
        $columns[5]->type = 'text';

        $columns[6]->name = 'footer';
        $columns[6]->type = 'text';

        $columns[7]->name = 'type';
        $columns[7]->type = 'text';

        $columns[8]->name = 'sortorder';
        $columns[8]->type = 'text';

        $columns[9]->name = 'group_id';
        $columns[9]->type = 'integer';

        return $this->create_table("templates",$columns);
    }


    /**
     * Creates supporting information table
     * 
     * @return boolean
     */
    protected function setup_supporting_table(){
        $columns = $this->define_basic_columns();

        $columns[1]->name = 'variable';
        $columns[1]->type = 'text';

        $columns[2]->name = 'val';
        $columns[2]->type = 'text';

        return $this->create_table("supportinginfo",$columns);
    }


    /**
     * Creates comments table
     * 
     * @return boolean
     */
    protected function setup_comments_table(){
        $columns = $this->define_basic_columns();

        $columns[1]->name = 'record_id';
        $columns[1]->type = 'integer';

        $columns[2]->name = 'comment';
        $columns[2]->type = 'longtext';

        $columns[3]->name = 'group_id';
        $columns[3]->type = 'integer';

        $columns = array_merge($columns,$this->define_editor_columns());

        return $this->create_table("comments",$columns);
    }


    /**
     * Checks to see if the database needs to be upgraded
     * 
     * @return mixed
     */
    private function needs_upgrade(){
        if (!$this->table_exists("supportinginfo")) {
            return 1.01;
        }

        $columns = array('val');

        $parameters = array();
        $parameters[0]->name = 'variable';
        $parameters[0]->value = 'version';
        $parameters[0]->operator = 'equals';

        $supportinginfo = $this->get_file_db_version();

        if (!$supportinginfo) {
            return 1.01;
        }

        $current_db_version = (float) $supportinginfo;

        if ($current_db_version < $this->get_version()) {
            return $current_db_version;
        }

        return false;
    }


    /**
     * Checks to see if the database needs to be upgraded
     * 
     * @return boolean
     */
    private function upgrade($db_version){
        if ($db_version<1.1) {
            $columns[0]->name = 'label';
            $columns[0]->value = get_string('id','dataplus');

            $columns[1]->name = 'group_id';
            $columns[1]->value = '0';

            $parameters[0]->name = 'name';
            $parameters[0]->value = 'id';
            $parameters[0]->operator = 'equals';

            $result = $this->update_record("column",$columns,$parameters);

            if (!$result) {
                return $result;
            }

            $result = $this->setup_supporting_table();

            if (!$result) {
                return $result;
            }

            $result = $this->add_column_query("templates","css","text");

            if (!$result) {
                return $result;
            }

            $result =  $this->add_column_query("templates","js","text");

            if (!$result) {
                return $result;
            }

            $columns[0]->name = 'type';
            $columns[0]->value = 'view';

            $parameters[0]->name = 'type';
            $parameters[0]->value = 'view-template';
            $parameters[0]->operator = 'equals';

            $result = $this->update_record("templates",$columns,$parameters);

            if (!$result) {
                return $result;
            }
        }

        if ($db_version<1.11) {
            $result = $this->set_file_db_domain();
               
            if (!$result) {
                return $result;
            }
        }

        if ($db_version<1.2) {
            $result = $this->setup_comments_table();

            if (!$result) {
                return $result;
            }
        }

        if ($db_version<1.201) {
            $result = $this->add_column_query("templates","comments","text");

            if (!$result) {
                return $result;
            }
        }

        if ($db_version<1.205) {
            //fix the content table if it has no primary key
            $column = $this->get_column_info('content','id');

            if ($column->pk === "0") {
                $parameters[0]->name = 'name';
                $parameters[0]->value = 'id';
                $parameters[0]->operator = 'equals';
                
                $id_col = $this->list_table_columns('content',$parameters);
                $id_col = $id_col[0];
               
                $id_col->primary_key = "1";
                $id_col->autoincrement = "1";
                $id_col->not_null = "1";

                $result = $this->alter_column($id_col);

                if (!$result) {
                    return $result;
                }

                $records = $this->query_dataplus_database();

                return true;
            }
        }

        /*
         * previously the following db versions were 1.202 and 1.203, but there appear to have been instances
         * of the upgrade running without the sortorder column being added, at least on the tt build.
         * Therefore we seek to upgrade to 1.204 with a check to see if the sortorder cols already there.
         */
        if ($db_version<1.207) {
            if (parent::check_column_exists("templates","sortorder")) {
                //the sortorder column is already there so don't do antything
            }
            else {
                $result = $this->add_column_query("templates","sortorder","text");

                if (!$result) {
                    return $result;
                }
            }
        }

        return $this->set_file_db_version();
    }


    /**
     * Adds some additional supporting columns for supporting groups and form field display (also 
     * a field for hiding fields, only supported in specific contexts)
     * 
     * @param array
     */
    protected function get_columns_table_column_details(){
        $columns = parent::get_columns_table_column_details();

        $i = sizeof($columns);

        $columns[$i]->name = 'form_field_type';
        $columns[$i]->type = 'text';

        $i++;

        $columns[$i]->name = 'form_field_options';
        $columns[$i]->type = 'text';

        $i++;

        $columns[$i]->name = 'hidden';
        $columns[$i]->type = 'boolean';

        $i++;

        $columns[$i]->name = 'group_id';
        $columns[$i]->type = 'integer';

        return $columns;
    }


    /**
     * details of the columns in the content table that contain information on the record creator, last update
     * and group
     * 
     * @return array
     */
    public function detail_content_table_supporting_columns(){
        $basic_columns = $this->define_basic_columns();

        $editor_columns = $this->define_editor_columns();

        $columns[0]->name = 'group_id';
        $columns[0]->label = '';
        $columns[0]->type = 'integer';
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        return array_merge($basic_columns, $editor_columns, $columns);
    }


    /**
     * returns the details of the columns used to store creator information
     * 
     * @return array
     */
    public function define_creator_columns(){
        $columns[0]->name = 'creator';
        $columns[0]->label = get_string('creator','dataplus');
        $columns[0]->type = 'text';
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        $columns[1]->name = 'creator_id';
        $columns[1]->label = get_string('creatorid','dataplus');
        $columns[1]->type = 'text';
        $columns[1]->group_id = '0';
        $columns[1]->hidden = true;

        $columns[2]->name = 'created_time';
        $columns[2]->label = get_string('created','dataplus');
        $columns[2]->type = 'datetime';
        $columns[2]->group_id = '0';
        $columns[2]->hidden = false;

        return $columns;
    }


    /**
     * returns the details of the columns used to store creator information
     * 
     * @return array
     */
    public function define_updater_columns(){
        
        $columns[0]->name = 'last_update';
        $columns[0]->label = get_string('updater','dataplus');
        $columns[0]->type = 'text';
        $columns[0]->group_id = '0';
        $columns[0]->hidden = false;

        $columns[1]->name = 'last_update_id';
        $columns[1]->label = get_string('updaterid','dataplus');
        $columns[1]->type = 'text';
        $columns[1]->group_id = '0';
        $columns[1]->hidden = true;

        $columns[2]->name = 'last_update_time';
        $columns[2]->label = get_string('updated','dataplus');
        $columns[2]->type = 'datetime';
        $columns[2]->group_id = '0';
        $columns[2]->hidden = false;

        return $columns;
    }

    
    /**
     * Returns details of editor and updater columns
     * 
     * @return array
     */
    public function define_editor_columns(){
        return array_merge($this->define_creator_columns(),$this->define_updater_columns());
    }


    /**
     * returns an array with the names of form field types and their labels
     * 
     * @return array
     */
    public function get_field_types(){
        return array(
            'smalltext' => get_string('field_smalltext', 'dataplus'),
            'longtext' => get_string('field_longtext', 'dataplus'),
            'date' => get_string('field_date', 'dataplus'),
            'datetime' => get_string('field_datetime', 'dataplus'),
            'number' => get_string('field_number', 'dataplus'),
            'image' => get_string('field_image', 'dataplus'),
            'file' => get_string('field_file', 'dataplus'),
            'url' => get_string('field_url', 'dataplus'),
            'boolean' => get_string('field_boolean', 'dataplus'),
            'menusingle' => get_string('field_menusingle', 'dataplus'),
            'menumultiple' => get_string('field_menumultiple', 'dataplus'));
    }


    /**
     * gets the label for a field type
     *
     * @param string $field_type
     * @return mixed
     */
    public function get_field_type_description($field_type){
        $types = $this->get_field_types();

        if (isset($types[$field_type])) {
            return $types[$field_type];
        } else {
            return false;
        }
   	}


    /**
     * returns an array of form field types mapped to SQLite data types
     * 
     * @return array
     */
    public function get_field_data_types(){
        return array(
            'smalltext' => 'text',
            'longtext' => 'text',
            'date' => 'date',
            'datetime' => 'date',
            'number' => 'integer',
            'image' => 'text',
            'file' => 'text',
            'url' => 'text',
            'boolean' => 'boolean',
            'menusingle' => 'text',
            'menumultiple' => 'text',
            'supp' => 'text');
    }


    /**
     * gets the data type for a form field type
     *
     * @param string $field_type
     * @return mixed
    */
    public function get_field_data_type($field_type){
        $types = $this->get_field_data_types();

        if (isset($types[$field_type])) {
            return $types[$field_type];
        }

        return false;
    }


    /**
     * this is added to the end of names of additional fields used to store supporting information (image alt tags,
     * url descriptors, etc).
     * 
     * @return string
     */
    public function get_supporting_suffix(){
        return '000SUPP';
    }


    /**
     * returns an array of the form field types that have  addition fields for supporting information
     *
     * @return array
     */
    public function get_combi_fields(){
        return array(
            'url'=>array('desc'),
            'image'=>array('alt'));
    }


    /**
     * returns an array of the names of combi fields
     *
     * @return array
     */
    public function get_combi_fields_types(){
        $fields = $this->get_combi_fields();
        $types = array();

        foreach ($fields as $type=>$val) {
            $types[] = $type;
        }

        return $types;
    }


    /**
     * list the supporting columns in the content table
     *
     * @param boolean $include_hidden
     * @return array
     */
    public function list_content_table_supporting_columns($include_hidden = false){
        $cols = $this->detail_content_table_supporting_columns();
        $list = array();

        foreach ($cols as $col) {
            if (!$include_hidden && $col->hidden) {
                continue;
            }

            $list[] = $col->name;
        }

        return $list;
    }


    /**
     * list the columns in the content table.  $parameters can be specified for the query.  Supporting fields
     * can be included/ommitted
     *
     * @param boolean $include_supporting
     * @param array $parameters
     * @return array
     */
    public function list_dataplus_table_columns($include_supporting = false, $parameters = array()){
        $columns = $this->list_table_columns('content',$parameters);
        $end = sizeof($columns);
        $supporting_cols = $this->list_content_table_supporting_columns(true);

        if (!$include_supporting) {
            $supp_suffix_len = 0 - strlen($this->get_supporting_suffix());

            for ($i=0; $i<$end; $i++) {
                $suffix_match = (substr($columns[$i]->name,$supp_suffix_len) == $this->get_supporting_suffix());

                if (in_array($columns[$i]->name,$supporting_cols) || $suffix_match) {
                    unset($columns[$i]);
                }
            }
        }

        return $columns;
    }


    /**
     * list the columns in the content table as an array.  $parameters can be specified for the query.  Supporting fields
     * can be included/ommitted
     *
     * @param boolean $include_supporting
     * @param array $parameters
     * @return unknown
     */
    public function list_dataplus_table_columns_array($include_supporting = false, $parameters = array()){
        $columns = $this->list_dataplus_table_columns($include_supporting, $parameters);
        $output = array();

        foreach ($columns as $r) {
            if (empty($r->label) || empty($r->name)) {
                continue;
            }

            $output[$r->name] = $r->label;
        }

        return $output;
    }


    /**
     * returns an array with the names of the columns from the content table
     *
     * @param boolean $include_supporting
     * @return array
     */
    public function list_table_columns_names($include_supporting = false){
        $columns = $this->list_dataplus_table_columns($include_supporting);
        $names = array();

        foreach ($columns as $column) {
            $names[] = $column->name;
        }

        return $names;
    }


    /**
     * returns an array with the names of the date or datetime columns from the content table
     *
     * @param boolean $include_supporting
     * @return array
     */
    public function list_table_datetime_column_names(){
        $columns = $this->list_dataplus_table_columns();
        $names = array();

        foreach ($columns as $column) {
            if ($column->type == 'date' || $column->type == 'datetime') {
                $names[] = $column->name;
            }
        }

        return $names;
    }


    /**
     * return the name of a column from content from it's id.
     *
     * @param int $id
     * @return string
     */
    public function get_column_field_name($id){
        return parent::get_column_field_name('content',$id);
    }


    /**
     * returns the form_field_type of a column from it's id.
     *
     * @param int $id
     * @return mixed
     */
    public function get_column_field_type($id){
        return $this->get_column_field('content',$id,'form_field_type');
    }


    /**
     * check a column with a given name exists
     *
     * @param string $column_name
     * @return boolean
     */
    public function check_column_exists($column_name){
        return parent::check_column_exists('content',$column_name);
    }


    /**
     * Checks the SQLite database loaded is valid for use in DataPlus.  It checks there are not more than 4
     * tables and that 'content' and 'templates' tables exist
     * 
     * @return mixed
     */
    public function validate_database(){
        $validate = parent::validate_database();

        if ($validate !== true) {
            return $validate;
        }

        $table_count = $this->count_database_query('sqlite_master');

        if ($table_count>6) {
            return get_string('validate_toomanytables','dataplus');
        }

        $content_exists = $this->table_exists('content');

        if (!$content_exists) {
            return get_string('validate_table_content','dataplus');
        }

        $templates_exists = $this->table_exists('templates');

        if (!$templates_exists) {
            return get_string('validate_table_templates','dataplus');
        }

        $templates_exists = $this->table_exists('supportinginfo');

        if(!$templates_exists){
            return get_string('validate_table_supportinginfo','dataplus');
        }

        return true;
    }


    /**
     * add a column to a table
     *
     * @param string $column_label
     * @param string $form_field_type
     * @param string $form_field_options
     * @param string/int $group_id
     * @return boolean
     */
    public function add_column($column_label, $form_field_type, $form_field_options = null, $group_id = '0'){
        $type = $this->get_field_data_type($form_field_type);
        $name = parent::add_column($column_label,$type);

        if ($name === false) {
            return false;
        } else {
            $columns[0]->name = 'form_field_type';
            $columns[0]->value = $form_field_type;

            $columns[1]->name = 'form_field_options';
            $columns[1]->value = $form_field_options;

            $columns[2]->name = 'group_id';
            $columns[2]->value = $group_id;

            $parameters[0]->name = 'name';
            $parameters[0]->value = $name;
            $parameters[0]->operator = 'equals';

            $parameters[1]->name = 'table_name';
            $parameters[1]->value = 'content';
            $parameters[1]->operator = 'equals';

            $result = $this->update_record("column",$columns,$parameters);

            $combi_fields = $this->get_combi_fields();

            if (!empty($combi_fields[$form_field_type])) {
                foreach ($combi_fields[$form_field_type] as $field) {
                    $result = $this->add_supporting_column($name,$field);
                }
            }
        }

        return $result;
    }


    /**
     * adds a supporting column for field types that require it (e.g. alt tags for images, descriptors for URLs, etc)
     *
     * @param string $assoc_name
     * @return boolean
     */
    private function add_supporting_column($assoc_name, $name_extra = ''){
        $result = $this->add_column($assoc_name  . $name_extra . $this->get_supporting_suffix(), 'supp');

        return $result;
    }


    /**
     * Delete a column identified by the column id
     *
     * @param int $column_id
     * @return boolean
     */
    public function delete_column($column_id){
        $type = $this->get_column_field_type($column_id);
        $name = $this->get_column_field_name($column_id);
        $result = parent::delete_column('content', $column_id);

        if (!$result) {
            return false;
        }

        $combi_fields = $this->get_combi_fields();

        if (!empty($combi_fields[$type])) {
            foreach ($combi_fields[$type] as $field) {
                $result = $this->delete_supporting_column($name,$field);
            }
       }

        $templates = $this->get_templates();

        foreach ($templates as $template) {
            $temp = $template->record;
            $rep = str_replace("[[{$name}]]","",$temp);

            if (strcmp($temp,$rep) != 0) {
                $template->record = $rep;
                $vals = $this->convert_object_to_values($template);

                $this->update_template($vals);
            }
        }

        return $result;
    }


    /**
     * delete a supporting column by its name
     *
     * @param string $name
     * @return boolean
     */
    private	function delete_supporting_column($name,$extra = ''){
        $cols = $this->list_dataplus_table_columns(true);
        $result = false;

        foreach ($cols as $col) {
            if ($col->name == $name.$extra.$this->get_supporting_suffix()) {
                $result = $this->delete_column($col->id);

                break;
            }
        }

        return $result;
    }


    /**
     * change a columns label, type, group and/or options
     *
     * @param obj $column_details
     * @return array
     */
    public function alter_column($column_details){
        global $currentgroup;

        if (empty($column_details->type)) {
            $column_details->type = $this->get_field_data_type($column_details->form_field_type);
        }

        $stored_column = $this->get_column_details($column_details->id);

        $result = parent::alter_column('content',$column_details);

        if (!$result) {
            return $result;
        }

        $update = array();
        $i = 0;
        $supp_alter = false;

        if ($stored_column->form_field_type !== $column_details->form_field_type) {
            $type = $this->get_field_data_type($column_details->form_field_type);

            $update[$i]->name  = 'form_field_type';
            $update[$i]->value = $column_details->form_field_type;

            $i++;

            $supp_alter = 'TYPE';
            $result = parent::alter_column('content',$column_details);

            if ($result === "COLUMNEXISTS"  || $result === false) {
                return $result;
            }
        }

        if (isset($column_details->form_field_options)) {
            $update[$i]->name = 'form_field_options';
            $update[$i]->value = $column_details->form_field_options;
            $i++;
        }

        $update[$i]->name  = 'group_id';

        if (isset($column_details->group_id)) {
            $update[$i]->value = $column_details->group_id;
        } else {
            $update[$i]->value = '';
        }

        $i++;

        if(sizeof($update)>0){
            $parameters = array();
            $parameters[0]->name = 'id';
            $parameters[0]->value = $column_details->id;
            $parameters[0]->operator = 'equals';

            $parameters[1]->name = 'table_name';
            $parameters[1]->value = 'content';
            $parameters[1]->operator = 'equals';

            $result = $this->update_record('column',$update,$parameters);

            if ($result !== true) {
                return $result;
            }
        }

        $name = $this->create_valid_object_name($column_details->label);
        $label = $column_details->label;

        if ($supp_alter == 'TYPE') {
            $types = $this->get_combi_fields_types();

            if (in_array($stored_column->form_field_type,$types)) {
                $result = $this->delete_supporting_column($stored_column->name);
            }

            if (in_array($column_details->form_field_type,$types)) {
                $result = $this->add_supporting_column($name,$label,$column_details->form_field_type);
            }
        } else if (in_array($column_details->form_field_type,$this->get_combi_fields_types())) {
            $result = $this->rename_supporting_column($stored_column->name, $name, $label);
        }

        $templates = $this->get_templates();

        foreach ($templates as $template) {
            $temp = $template->record;
            $name = $this->create_valid_object_name($column_details->label);
            $rep = str_replace("[[{$stored_column->name}]]","[[{$name}]]",$temp);

            if (strcmp($temp,$rep) != 0) {
                $template->record = $rep;
                $vals = $this->convert_object_to_values($template);

                $this->update_template($vals);
            }
        }

        return $result;
    }


    /**
     * rename a supporting column
     *
     * @param string $assoc_name
     * @param string $assoc_new_name
     * @param string $assoc_label
     * @return boolean
     */
    private function rename_supporting_column($assoc_name, $extra, $assoc_new_name, $assoc_label){
        $cols = $this->list_dataplus_table_columns(true);
        $new_name = $assoc_new_name . $extra . $this->get_supporting_suffix();

        foreach ($cols as $col) {
            if ($col->name == $assoc_name . $extra . $this->get_supporting_suffix()) {
                $id = $col->id;

                break;
            }
        }

        $detail->id = $id;
        $detail->label = $new_name;
        $detail->form_field_type = 'supp';

        $result = $this->alter_column($detail);

        return $result;
    }


    /**
     * insert a record.  Fields and there values are specified in the columns array.
     * Creator, last update and group information
     *
     * @param array $columns
     * @return array
     */
    public function insert_dataplus_record($columns){
        global $USER, $currentgroup;

        $i = sizeof($columns);

        $columns[$i]->name  = 'creator';
        $columns[$i]->value = $USER->firstname.' '.$USER->lastname;

        $i++;
        $columns[$i]->name  = 'creator_id';
        $columns[$i]->value = $USER->id;

        $i++;
        $columns[$i]->name  = 'created_time';
        $columns[$i]->value = time();

        $i++;
        $columns[$i]->name  = 'last_update';
        $columns[$i]->value = $USER->firstname.' '.$USER->lastname;

        $i++;
        $columns[$i]->name  = 'last_update_id';
        $columns[$i]->value = $USER->id;

        $i++;
        $columns[$i]->name  = 'last_update_time';
        $columns[$i]->value = time();

        return $this->insert_record('content',$columns);
    }


    /**
     * delete records.  If no parameters are set, all records will be deleted.
     *
     * @param array $parameters
     * @return boolean
     */
    public function delete_dataplus_record($parameters = null){
        return $this->delete_record('content',$parameters);
    }


    /**
     * Make changes to a user template.
     *
     * @param array $template
     * @return boolean
     */
    public function update_template($template){
        foreach ($template as $t) {
            if ($t->name == 'type') {
                $type = $t->value;
            }

            if ($t->name == 'group_id') {
                $group_id = $t->value;
            }
        }

        $exists = $this->get_template($type, false); 

        if (empty($exists)) {
            return $this->insert_record('templates',$template);
        }

        $parameters = array();
        $parameters[0]->name = 'type';
        $parameters[0]->value = $type;
        $parameters[0]->operator = 'equals';

        $parameters[1]->name = 'group_id';
        $parameters[1]->value = $group_id;
        $parameters[1]->operator = 'equals';
        $parameters[1]->andor = 'AND';

        return $this->update_record('templates',$template,$parameters);
    }


    /**
     * make changes to an existing columns specified of a record or records according to parameters
     *
     * @param array $columns
     * @param array $parameters
     * @return boolean
     */
    public function update_dataplus_record($columns,$parameters){
        global $USER, $currentgroup;

        $i = sizeof($columns);
        $columns[$i]->name = 'last_update';
        $columns[$i]->value = $USER->firstname.' '.$USER->lastname;

        $i++;
        $columns[$i]->name = 'last_update_id';
        $columns[$i]->value = $USER->id;

        $i++;
        $columns[$i]->name = 'last_update_time';
        $columns[$i]->value = time();

        return $this->update_record('content',$columns,$parameters);
    }


    /**
     * return a template from the database.  In groups mode, if no template for the current group is found,
     * this function will look for a template set to 'all participants'.
     *
     * @param string $type
     * @param boolean $check_all_participants
     * @return mixed
     */
    public function get_template($type,$check_all_participants = true){
        global $currentgroup;

        $columns = array('header','record','footer','js','css','comments','sortorder');

        $parameters = array();
        $parameters[0]->name = 'type';
        $parameters[0]->value = $type;
        $parameters[0]->operator = 'equals';

        $parameters[1]->name = 'group_id';
        $parameters[1]->value = $currentgroup;
        $parameters[1]->operator = 'equals';
        $parameters[1]->andor = 'AND';

        $template = $this->query_database('templates',$columns,$parameters);

        if ($check_all_participants && empty($template)) {
            $parameters[1]->name = 'group_id';
            $parameters[1]->value = '0';
            $parameters[1]->operator = 'equals';
            $parameters[1]->andor = 'AND';

            $template = $this->query_database('templates',$columns,$parameters);
        }

        if ($check_all_participants && empty($template)) {
            $parameters[1]->name = 'group_id';
            $parameters[1]->value = '';
            $parameters[1]->operator = 'equals';
            $parameters[1]->andor = 'AND';

            $template = $this->query_database('templates',$columns,$parameters);
        }

        if (empty($template)) {
            return false;
        } else {
            return $template[0];
        }
    }


    /**
     * gets all the templates from the database
     * 
     * @return array
     */
    public function get_templates(){
        $columns = array('id','header','record','footer','type','group_id','comments');
        $templates = $this->query_database('templates',$columns);

        return $templates;
    }


    /**
     * deletes all templates from the current group (if applicable) of a given type
     *
     * @param string $type
     * @return unknown
     */
    public function delete_template($type){
        global $currentgroup;

        $delete_params[0]->name = 'group_id';
        $delete_params[0]->value = $currentgroup;
        $delete_params[0]->operator = 'equals';

        $delete_params[1]->name = 'type';
        $delete_params[1]->value = $type;
        $delete_params[1]->operator = 'equals';

        return $this->delete_record('templates',$delete_params);
    }


    /**
     * return a query containing given columns to given parameters to a set limit in a particular order.  
     * Should return everything if no params are set
     *
     * @param array $columns
     * @param array $parameters
     * @param array $limit
     * @param array $order
     * @return array
     */
    public function query_dataplus_database($columns = null,$parameters = null, $limit = null, $order = null){
        if (is_null($columns)) {
            $columns_details = $this->list_dataplus_table_columns(true);

            foreach ($columns_details as $cd) {
                $columns[] = $cd->name;
            }
        }

        return $this->query_database('content',$columns,$parameters,$limit, $order);
    }


    /**
     * Returns a single result (if the query returns more than one result then the first result is returned).
     *
     * @param array $columns
     * @param array $parameters
     * @param array $order
     * @return object
     */
    public function query_dataplus_database_single($columns = null,$parameters = null, $order = null){
        if (is_null($columns)) {
            $columns_details = $this->list_dataplus_table_columns(true);

            foreach ($columns_details as $cd) {
                $columns[] = $cd->name;
            }
        }

        return $this->query_database_single('content',$columns,$parameters,$order);
    }


    /**
     * Counts the results of a query
     *
     * @param array $parameters
     * @return int
     */
    public function count_dataplus_database_query($parameters = null){
        return $this->count_database_query('content',$parameters);
    }


    /**
     * Changes all the dates in the database to UK dates.
     * 
     * @return boolean
     */
    public function generate_UK_dates(){
        $cols = $this->list_dataplus_table_columns(true);
        $date_cols = array();
        $date_time_cols = array();

        foreach ($cols as $col) {
            if ($col->type == 'date') {
                $date_cols[] = $col->name;
            } else if ($col->type == 'datetime') {
                $date_time_cols[] = $col->name;
            }
        }

        $all_cols = array_merge($date_time_cols, $date_cols);
        $all_cols[] = 'id';
        $records = $this->query_dataplus_database($all_cols);

        foreach ($records as $record) {
            $parameters[0]->name = 'id';
            $parameters[0]->value = $record->id;
            $parameters[0]->operator = 'equals';

            $update = array();

            $i = 0;

            foreach ($date_cols as $d) {
                if (!empty($record->$d)) {
                    $update[$i]->name = $d;
                    $update[$i]->value = Date('d/m/Y', $record->$d);
                    $i++;
                }
            }

            foreach ($date_time_cols as $d) {
                if (!empty($record->$d)) {
                    $update[$i]->name = $d;
                    $update[$i]->value = Date('d/m/Y H:i:s', $record->$d);
                    $i++;
                }
            }

            if (!empty($update) && !$this->update_record('content',$update,$parameters)) {
                return false;
            }
        }

        return true;
    }


    /**
     * Checks to see if there are any records or columns in the database
     * 
     * @return boolean
     */
    public function unused_database(){
        $records = $this->count_dataplus_database_query();

        if ($records > 0) {
            return false;
        }

        $columns = $this->count_database_query('column');

        if ($columns > sizeof($this->detail_content_table_supporting_columns())) {
            return false;
        }

        return true;
    }


    /**
     * deletes all the user generated data from a database
     * 
     * @return boolean
     */
    public function empty_user_data(){
        if (!$this->delete_dataplus_record()){
            return false;
        }

        return true;
    }


    /**
     * returns the number of entries created by a particular user
     * 
     * @return int
     */
    public function count_user_entries(){
        global $USER;

        $parameters[0]->name = 'creator_id';
        $parameters[0]->value = $USER->id;
        $parameters[0]->operator = 'equals';

        return $this->count_dataplus_database_query($parameters);
    }


    /**
     * count the number of user generated fields in a database
     * 
     * @return int
     */
	public function count_user_fields(){
        $supporting_cols = $this->detail_content_table_supporting_columns();
        $parameters = array();

        foreach ($supporting_cols as $col) {
            $s = sizeof($parameters);
            $parameters[$s]->name = 'name';
            $parameters[$s]->value = $col->name;
            $parameters[$s]->operator = 'notequal';
            $parameters[$s]->andor = 'AND';
        }

        return $this->count_database_query('column',$parameters);
    }


    /**
     * converts a query result into values compatible for database edits or updates
     *
     * @param obj $obj
     * @return array
     */
    public function convert_object_to_values($obj){
        $ar = array();
        $i = 0;

        foreach ($obj as $name=>$value) {
            $ar[$i]->name = $name;
            $ar[$i]->value = $value;
            $i++;
        }

        return $ar;
    }


    /**
     * Converts the fields from user ids to usernames
     * 
     * @param string field_name
     * @return boolean
     */
    public function ids_to_usernames($field_name){
        $updates = $this->query_dataplus_database(array($field_name));
        $updates_done = array();
        
        foreach ($updates as $u) {
            if (in_array($u->$field_name,$updates_done)) {
                continue;
            }

            $user_data = get_complete_user_data('id',$u->$field_name);
            $updates_done[] = $u->$field_name;
            $update[0]->name  = $field_name;

            if (!$user_data) {
                $update[0]->value = "UNKNOWN";
            } else {
                $update[0]->value = $user_data->username;
            }

            $parameters[0]->name = $field_name;
            $parameters[0]->value = $u->$field_name;
            $parameters[0]->operator = 'equals';

            if($this->update_record('content',$update,$parameters)){
                continue;
            } else {
                return false;
            }
        }

        return true;
    }


    /**
     * get comment table column names
     * @return array
     */
    public function get_comment_column_names(){
        return array('id',
                     'comment',
                     'group_id',
                     'creator',
                     'creator_id',
                     'created_time',
                     'last_update',
                     'last_update_id',
                     'last_update_time');
    }

    /**
     * insert a comment to the comment table.
     *
     * @param int $record_id
     * @param string $comment
     * @param string $groupid
     * @return boolean
     */
    public function insert_comment($record_id,$comment){
        global $USER, $currentgroup;

        $columns[0]->name = 'creator';
        $columns[0]->value = $USER->firstname.' '.$USER->lastname;

        $columns[1]->name = 'creator_id';
        $columns[1]->value = $USER->id;

        $columns[2]->name = 'created_time';
        $columns[2]->value = time();

        $columns[3]->name = 'last_update';
        $columns[3]->value = $USER->firstname.' '.$USER->lastname;

        $columns[4]->name = 'last_update_id';
        $columns[4]->value = $USER->id;

        $columns[5]->name = 'last_update_time';
        $columns[5]->value = time();

        $columns[6]->name = 'record_id';
        $columns[6]->value = $record_id;

        $columns[7]->name = 'comment';
        $columns[7]->value = $comment;

        $columns[8]->name = 'group_id';
        $columns[8]->value = $currentgroup;

        return $this->insert_record('comments',$columns);
    }

    /**
     * deletes a comment
     *
     * @param int $id
     * @return boolean
     */
    public function delete_comment($id){
        global $currentgroup;
        
        $params[0]->name = 'id';
        $params[0]->value = $id;
        $params[0]->operator = 'equals';

        return $this->delete_record('comments',$params);
    }


    /**
     * Make changes to a user comment.
     *
     * @param int $id
     * @param string $comment
     * return boolean
     */
    public function update_comment($id,$comment){
        global $USER;

        $columns[0]->name = 'comment';
        $columns[0]->value = $comment;

        $columns[1]->name = 'last_update';
        $columns[1]->value = $USER->firstname.' '.$USER->lastname;

        $columns[2]->name = 'last_update_id';
        $columns[2]->value = $USER->id;

        $columns[3]->name = 'last_update_time';
        $columns[3]->value = time();

        $parameters = array();
        $parameters[0]->name = 'id';
        $parameters[0]->value = $id;
        $parameters[0]->operator = 'equals';

        return $this->update_record('comments',$columns,$parameters);
    }


    /**
     * return a comment from the database.
     *
     * @param int $id
     * @return mixed
     */
    public function get_comment($id, $additional_parameters = null){
        global $currentgroup;

        $columns = $this->get_comment_column_names();

        $parameters = array();
        $parameters[0]->name = 'id';
        $parameters[0]->value = $id;
        $parameters[0]->operator = 'equals';

        if (!is_null($additional_parameters)) {
            $parameters = array_merge($parameters,$additional_parameters);
        }

        $comment = $this->query_database('comments',$columns,$parameters);

        if (empty($comment)) {
            return false;
        } else {
            return $comment[0];
        }
    }


    /**
     * return all the comments for a particular record
     *
     * @param int $rid
     * @return array
     */
    public function get_record_comments($rid, $end = NULL, $start = NULL, $additional_parameters = null){
        global $currentgroup;

        $columns = $this->get_comment_column_names();

        $parameters = array();
        $parameters[0]->name = 'record_id';
        $parameters[0]->value = $rid;
        $parameters[0]->operator = 'equals';

        if (!is_null($end)) {
            $parameters[1]->name = 'id';
            $parameters[1]->value = $end;
            $parameters[1]->operator = 'lessthan';
            $parameters[1]->andor = 'AND';
        }

        if (!is_null($start)) {
            $val = sizeof($parameters) +1;
            $parameters[$val]->name = 'id';
            $parameters[$val]->value = $start;
            $parameters[$val]->operator = 'greaterthan';
            $parameters[$val]->andor = 'AND';
        }

        if (!is_null($additional_parameters)) {
            $parameters = array_merge($parameters,$additional_parameters);
        }

        $comments = $this->query_database('comments',$columns,$parameters);

        if (empty($comments)) {
            return false;
        } else {
            return $comments;
        }
    }
}